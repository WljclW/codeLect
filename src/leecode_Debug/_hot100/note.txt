1. 用栈实现对队列（需要使用两个栈，stackIn（输入栈）、stackOut（输出栈））。
   {
        在push数据的时候，只要数据放进输入栈就好，但在pop的时候，操作就复杂一些，输出栈如果为
   空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接
   从出栈弹出数据就可以了。
        最后如何判断队列为空呢？如果进栈和出栈都为空的话，说明模拟的队列为空了。
   }
    ①入队操作时仅仅把数据入栈stackIn;
    ②出队操作时先把stackIn的数据一次弹出，入栈stackOut。然后再弹出栈顶.
2. 实现最小栈（需要两个栈，stack、min_stack）
    ①元素入栈时。首先必须进入到stack；其次如果这个元素小于栈顶元素，则需要入栈min_stack；
    ②出栈时。首先必须弹出stack的栈顶；其次如果这个栈顶也是min_stack的栈顶，也需要从min_stack
 弹出栈顶。【注意】这里和最小栈栈顶比较需要使用“equals方法”，因此Integer仅仅缓存了[-127,128]这
 些数，其他的比较必须使用equals方法，不能使用==，==是判断引用的
3. 用队列实现栈。
    {
         一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到
    队列尾部，此时再去弹出元素就是栈的顺序了。
    }
    ①入栈时，元素直接进入队列
    ②出栈时，将元素依次从队头弹出，然后添加到队尾；剩下最后一个元素的时候直接弹出。（因为是一
  个队列，因此开始的时候需要获取队列的大小，从而判断是不是到达队尾）
    ③获取栈顶元素时。直接使用peekLast()获取队列的最后一个；

4. 关于java的SPI机制参考：https://pdai.tech/md/java/advanced/java-advanced-spi.html
5. Error的源码注释：error及其子类是不应该被捕获的，即不能写在throws子句；并且在编译期时期，error及其子类是不受检的异常。。————error及其子类是不应该发生的错误！
   Exception的源码注释：Exception类及它的子类（子类不能同时是RuntimeException的子类）是受检异常。即这些异常是可以写在throws中被抛出
 来。
====================================================final关键字的作用===================================================
1. 说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做?
    涉及模式中有两种重要的关系：一是继承/实现（继承父类，实现接口）；二是组合（类似于静态代理的模式即内部持有）。
2. 方法的重载和重写
    final修饰的方法是不能被重写的；但是是可以重载的
        public class FinalExampleParent {
            public final void test() {
            }

            public final void test(String str) {
            }
        }

    private修饰的方法可以认为就是final修饰的
3. 修饰字段的时候：
    无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据！
=====================================================StringBuffer和StringBuilder======================================
相同的点：
    可变的，不会像String一样每一次更新都会生成一个新的字符串；都是用char[]存储；可以动态扩容
不同的点：
    StringBuffer是线程安全的(通过syncronized关键字保证线程安全)，涉及加锁过程；StringBuilder不是线程安全的
======================================================“==”equals/hashcode==============================================
1. == 对于基本数据类型就是比较值是不是相等；对于引用类型判断的是引用是不是相等
2. equals
3. 规定“equals相等的时候，hashcode也必须是相等的”，反过来则不规定
============================================================final、finally、finalize()==================================
1. final修饰符：修饰类表示类不能被继承、修饰方法表示不能被重写、修饰变量表示只能被赋值一次
2. finally
3. finalize():Object 方法，GC 回收前由 垃圾回收线程调用一次(注意：只会被调用一次)；已被官方废弃（JDK 9 标注 @Deprecated），不建议
使用。
=========================================================dfs、递归、回溯===============================================
1. dfs是一种搜索方式。指沿着一条路径一直搜索下去直到没路走，具体实现时可以使用栈 或者 递归 来实现。
2. 递归是一种实现方式。指的是一个函数直接 或者 间接的 调用自己
3. 本质就是”DFS+状态回退“
=========================================================集合元素遍历的方式============================================
比如，对于集合”LinkedList<Integer> res = new LinkedList<>();“
方法1：使用迭代器————使用场景：在遍历的过程中会删除元素
    Iterator<Integer> iterator = res.iterator();
    while (iterator.hasNext()){
        System.out.println(iterator.next());
    }
方法2：普通的for循环
    for (int i = 0; i < res.size(); i++) {
        System.out.println(res.get(i));
    }
方法3：for-each循环————不能在for-each的过程中删除元素！
    for (Integer cur:res){
        System.out.println(cur);
    }
【补充说明】迭代器方式、for-each方式底层都是迭代器的方式。但是前者可以边遍历边删除，后者边遍历边删除时会抛出异常ConcurrentModificationException。
【补充说明】为什么迭代器方式在遍历集合的过程中，删除元素不会抛出异常?
       前置知识：java集合中的经典问题：fail-fast机制、结构性修改
       Iterator 是集合内部的合法访问器，它记录了集合的修改次数（expectedModCount），每次调用 iterator.remove()，都会：
            删除当前元素；更新 modCount 和 expectedModCount 保持一致
            所以不会触发 ConcurrentModificationException
==========================================================整型数组求和================================================
        比如，有一个数组：int[] flags = new int[ratings.length];
1. 使用for循环
    int sum = 0;
    for (int i = 0; i < flags.length; i++) {
        sum += flags[i];
    }
2. 增强for循环
    int sum = 0;
    for (int val : flags) {
        sum += val;
    }
3. 使用java8的Stream
    Arrays.stream(flags).sum();
============================================================算法题tips================================================
1.  ①一般情况下寻找链表的中间节点都是下面的方法（奇数节点时，slow会来到中间节点；偶数个节点时，slow会来到中间两个节点的后一个）：
            private ListNode findMid(ListNode head) {
                ListNode slow = head,fast = head;
                while (fast!=null&&fast.next!=null){
                    slow = slow.next;
                    fast  =fast.next.next;
                }
                return slow;
            }

    ②只有一个题例外情况，”排序链表“。这个题slow指针在偶数节点的情况下要来到中间节点的前一个节点，原因：需要将前一半的最后一个节点指
        向null,否则会出现死循环。
            private ListNode findMid(ListNode head) {
                ListNode slow = head,fast = head.next;
                while (fast!=null && fast.next!=null){
                    slow = slow.next;
                    fast = fast.next.next;
                }
                //如果是偶数个节点，代码执行到这里slow会指向中间两个节点的第一个；如果是奇数个节点，指向中间节点
                ListNode res = slow.next;
                slow.next = null; /**【说明】把前一半链表的最后节点指向null，其实最根本的原因在于结束排序的代码是“head==null||head.next==null”*/
                return res;
            }
   【总结】在快慢指针找中间节点时，fast指针的初始位置决定了寻找中间哪一个节点。slow指针不影响，固定初始值是head
    另一种关于②的写法（但是建议不要使用下面的写法）：
            ListNode slow = head, fast = head, prev = null;
            while (fast != null && fast.next != null) {
                prev = slow; //使用prev节点记录slow的前一个节点
                slow = slow.next;
                fast = fast.next.next;
            }
            prev.next = null; // 断开链表成两段
2. LinkedList实现了List接口（普通列表） 以及 Deque接口（双端队列），因此一般情况下LinkedList作为队列来使用————
   如果作为队列使用：二叉树的迭代遍历、层序遍历
            offer————元素入队。实际上等价于调用offerLast，即在尾部添加元素。
            poll————元素出队列。实际上等价于调用pollFirst，即删除头部的元素
   如果作为双端队列使用（想象成横着的双端队列，头部是在左边，尾部是在右边）：双端队列求解滑动窗口的最大值
            offerLast————在双端队列的尾部添加元素
            pollLast————删除双端队列的最后一个元素

            offerFirst————在双端队列的头部添加元素
            pollFirst————删除双端队列的头部元素
   如果用作是栈，则调用push、pop、peek，与常规意义的含义是一样的。。但是这种情况下不能将变量声明为Stack<>，因为java中的栈有实际的
        类————Stack，并且这是一个实际的类，不是接口
   如果用做是列表，则调用用add()，remove().

   【补充说明】很多题目会使用到"最小栈"、"最大栈"问题，如果最后还使用到了从栈底挨个取出栈的元素组装答案，则有两种做法：
        做法1：使用“Stack<String> stack = new Stack<>();”，入栈push；出栈/从栈顶弹出pop()；最后
            从栈底挨个弹出的时候采用“for (String dir : stack)”
        做法2：使用“LinkedList<String> stack = new LinkedList<>();”，入栈就必须使用offerLast()：
            出栈/从栈顶弹出必须使用pollLast()；最后拼接答案从栈底挨个弹出的使用“for (String dir : stack)”
            【注】做法2中如果使用push()/pop()，最后发现拼接的答案是倒序的
        总结：具体的使用例子见codetop_10.simplifyPath---力扣71。除此以外，删除k位数字、删除字母使字典序最小也是一样的道理。
3. 二叉树的前、中、后迭代遍历，需要使用"栈"结构；二叉树的层序遍历需要使用"队列"结构。。但是使用时都可以用LinkedList来代替，要注意的就是
    变量需要使用LinkedList声明，即”LinkedList<Node> stack = new LinkedList<>();“、”LinkedList<Node> queue = new LinkedList<>();“
    是可以的，但是如果声明成List或者Deque接口类型是不对的，比如
            “Stack<Node> stack = new LinkedList<>();”————错误的原因是LinkedList并不是Stack子类，并且Stack并不是接口；
            “Deque<Node> stack = new LinkedList<>();”————错误的原因是Deque只能使用Deque的方法，就不能使用push、pop等方法了。
    【注意】我们把LinkedList当作什么使用，就使用它的什么方法。比如————
         ①当作栈使用，则使用方法push()、pop()
         ②当作队列使用，则使用offer()、poll()
         ③当作双端队列使用（此时把队列想象成横着放，左边是头，右边是尾），则操作时使用offerFirst()、pollFirst()、offerLast()、pollLast()
         ④当作普通的列表使用，则操作时使用add()、remove()
4. 更深入的理解“二叉树的题目就是使用遍历方法，对当前研究的节点做一些操作”？比如：
      ①翻转二叉树。就是在遍历到每一个节点的时候，交换该节点的左右孩子，然后继续研究其他的节点————注意不要使用中序遍历
      ②
   关于”二叉树层序遍历的使用“。比如：
      ①最大深度。最后队列为空的时候返回变量值
      ②最小深度。如果发现某一个节点的左右孩子节点都是null，就返回变量值
      ③662最大宽度。使用两个队列，一个存放具体的节点，另一个存放节点对应的序号。使用层序遍历时常见的用法！！！
            一个节点的序号是m，则左孩子节点的序号是2*n，右孩子节点的序号是2*n+1.....
      ④129求根节点到叶节点的数字之和。也是使用两个队列，一个用于存放具体的节点，另一个存放节点对应的路径值
5. 关于for循环的迭代次数问题————
   ①for (int i = 0; i < size - k - 1; i++)
       循环变量i是0开始，一直到size-k-1。因此：一共是size-k个节点，包括i=0时所在的节点！！！
   ②for (int i = 1; i < size - k; i++)
       循环变量i是1开始，一直到size-k。因此：一共是size-k个节点，包括i=1时所在的节点！！！
   【补充】关于这里的问题，见力扣61题旋转链表；402题删除k位数字（计数应该是从k到1，因此k大于0时执行循环，k=0的
        时候停止删除数字）

============https://msub.lyf520.xyz/api/v1/client/subscribe?token=771d27cf291ff7a8f605e3ee74b826bc
