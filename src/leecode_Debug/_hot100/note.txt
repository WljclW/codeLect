1. 用栈实现对队列（需要使用两个栈，stackIn（输入栈）、stackOut（输出栈））。
   {
        在push数据的时候，只要数据放进输入栈就好，但在pop的时候，操作就复杂一些，输出栈如果为
   空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接
   从出栈弹出数据就可以了。
        最后如何判断队列为空呢？如果进栈和出栈都为空的话，说明模拟的队列为空了。
   }
    ①入队操作时仅仅把数据入栈stackIn;
    ②出队操作时先把stackIn的数据一次弹出，入栈stackOut。然后再弹出栈顶.
2. 实现最小栈（需要两个栈，stack、min_stack）
    ①元素入栈时。首先必须进入到stack；其次如果这个元素小于栈顶元素，则需要入栈min_stack；
    ②出栈时。首先必须弹出stack的栈顶；其次如果这个栈顶也是min_stack的栈顶，也需要从min_stack
 弹出栈顶
3. 用队列实现栈。
    {
         一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到
    队列尾部，此时再去弹出元素就是栈的顺序了。
    }
    ①入栈时，元素直接进入队列
    ②出栈时，将元素依次从队头弹出，然后添加到队尾；剩下最后一个元素的时候直接弹出。（因为是一
  个队列，因此开始的时候需要获取队列的大小，从而判断是不是到达队尾）
    ③获取栈顶元素时。直接使用peekLast()获取队列的最后一个；

4. 关于java的SPI机制参考：https://pdai.tech/md/java/advanced/java-advanced-spi.html
5. Error的源码注释：error及其子类是不应该被捕获的，即不能写在throws子句；并且在编译期时期，error及其子类是不受检的异常。。————error及其子类是不应该发生的错误！
   Exception的源码注释：Exception类及它的子类（子类不能同时是RuntimeException的子类）是受检异常。即这些异常是可以写在throws中被抛出
 来。
====================================================final关键字的作用===================================================
1. 说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做?
    涉及模式中有两种重要的关系：一是继承/实现（继承父类，实现接口）；二是组合（类似于静态代理的模式即内部持有）。
2. 方法的重载和重写
    final修饰的方法是不能被重写的；但是是可以重载的
        public class FinalExampleParent {
            public final void test() {
            }

            public final void test(String str) {
            }
        }

    private修饰的方法可以认为就是final修饰的
3. 修饰字段的时候：
    无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据！